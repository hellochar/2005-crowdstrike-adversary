{"version":3,"sources":["App.tsx","reportWebVitals.ts","index.tsx"],"names":["ImageDropzone","onGotImage","onDrop","useCallback","files","rejected","event","forEach","file","reader","FileReader","onabort","console","log","onerror","onload","img","document","createElement","src","result","readAsDataURL","useDropzone","maxFiles","getRootProps","getInputProps","isDragActive","className","AdversaryRendering","driver","useRef","handleRef","React","canvas","current","AdversaryDriver","useEffect","setImage","ref","renderer","scene","camera","controls","adversary","adversaryMaterial","timeStarted","geom","PlaneGeometry","handleWindowResize","setSize","window","innerWidth","innerHeight","aspect","updateProjectionMatrix","animate","edge0","edge1","x","requestAnimationFrame","update","displacementScale","performance","now","MathUtils","clamp","render","this","WebGLRenderer","setPixelRatio","devicePixelRatio","Scene","PerspectiveCamera","position","set","lookAt","addEventListener","add","AmbientLight","directionalLight","DirectionalLight","background","Color","loadDefaultImage","OrbitControls","autoRotate","texture","Texture","needsUpdate","recreateAdversary","remove","dispose","MeshStandardMaterial","side","DoubleSide","map","displacementMap","roughness","metalness","Mesh","TextureLoader","load","error","image","width","height","context","getContext","drawImage","imageData","getImageData","vertices","vertex","imageDataIndex","mapLinear","y","brightness","data","z","scale","Math","max","computeFlatVertexNormals","App","useState","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","getElementById"],"mappings":"sTA8BA,IAAMA,EAED,SAAC,GAAoB,IAAlBC,EAAiB,EAAjBA,WACAC,EAASC,uBACb,SAACC,EAAeC,EAA2BC,GACzCF,EAAMG,SAAQ,SAACC,GACb,IAAMC,EAAS,IAAIC,WAEnBD,EAAOE,QAAU,kBAAMC,QAAQC,IAAI,6BACnCJ,EAAOK,QAAU,kBAAMF,QAAQC,IAAI,4BACnCJ,EAAOM,OAAS,WACd,IAAMC,EAAMC,SAASC,cAAc,OACnCF,EAAIG,IAAMV,EAAOW,OACjBnB,EAAWe,IAEbP,EAAOY,cAAcb,QAGzB,CAACP,IAhBoB,EAkB+BqB,YAAY,CAChEpB,SACAqB,SAAU,IAFJC,EAlBe,EAkBfA,aAAcC,EAlBC,EAkBDA,cAAeC,EAlBd,EAkBcA,aAKrC,OACE,8CAAKC,UAAU,YAAeH,KAA9B,cACE,qCAAWC,MACVC,EACC,wDAEA,6FAMFE,EAAqB,SAAC,GAAoD,IAAlDZ,EAAiD,EAAjDA,IACtBa,EAASC,mBACTC,EAAYC,IAAM7B,aAAY,SAAC8B,GACrB,MAAVA,IACFJ,EAAOK,QAAU,IAAIC,EAAgBF,MAEtC,IAMH,OALAG,qBAAU,WACc,MAAlBP,EAAOK,SAA0B,MAAPlB,GAC5Ba,EAAOK,QAAQG,SAASrB,KAEzB,CAACA,IACG,wBAAQsB,IAAKP,KAGhBI,E,WASJ,WAAmBF,GAA4B,IAAD,gCAA3BA,SAA2B,KARvCM,cAQuC,OAPvCC,WAOuC,OANvCC,YAMuC,OAL9CC,cAK8C,OAJ9CC,eAI8C,OAH9CC,uBAG8C,OAF9CC,YAAc,EAEgC,KAD9CC,KAAO,IAAIC,IAAc,IAAK,IAAK,IAAK,KACM,KAqF9CC,mBAAqB,WACnB,EAAKT,SAASU,QAAQC,OAAOC,WAAYD,OAAOE,aAChD,EAAKX,OAAOY,OAASH,OAAOC,WAAaD,OAAOE,YAChD,EAAKX,OAAOa,0BAxFgC,KA2F9CC,QAAU,WA+DZ,IAAoBC,EAAeC,EAAeC,EA9D9CC,sBAAsB,EAAKJ,SAC3B,EAAKb,SAASkB,SACgB,MAA1B,EAAKhB,oBACP,EAAKA,kBAAkBiB,kBACuC,IA0DhDL,EA1DD,EA0DgBC,EA1Db,IA0D4BC,EA1DtBI,YAAYC,MAAQ,EAAKlB,aA4DnDa,EAAIM,IAAUC,OAAOP,EAAIF,IAAUC,EAAQD,GAAQ,EAAK,IAE7CE,GAAK,EAAI,EAAIA,KA5DtB,EAAKnB,SAAS2B,OAAO,EAAK1B,MAAO,EAAKC,SAjGtC0B,KAAK5B,SAAW,IAAI6B,IAAc,CAAEnC,WACpCkC,KAAK5B,SAAS8B,cAAcnB,OAAOoB,kBAEnCH,KAAK3B,MAAQ,IAAI+B,IAEjBJ,KAAK1B,OAAS,IAAI+B,IAChB,GACAtB,OAAOC,WAAaD,OAAOE,YAC3B,EACA,KAEFe,KAAK1B,OAAOgC,SAASC,IAAI,IAAK,EAAG,KACjCP,KAAK1B,OAAOkC,OAAO,EAAG,EAAG,GAGzBR,KAAKnB,qBACLE,OAAO0B,iBAAiB,SAAUT,KAAKnB,oBAEvCmB,KAAK3B,MAAMqC,IAAI,IAAIC,IAAa,UAChC,IAAMC,EAAmB,IAAIC,IAAiB,SAAU,GACxDD,EAAiBN,SAASC,IAAI,EAAG,EAAG,IACpCP,KAAK3B,MAAMqC,IAAIE,GACfZ,KAAK3B,MAAMyC,WAAa,IAAIC,IAAM,EAAG,EAAG,GASxCf,KAAKgB,mBAELhB,KAAKzB,SAAW,IAAI0C,IAAcjB,KAAK1B,OAAQ0B,KAAKlC,QACpDkC,KAAKzB,SAAS2C,YAAa,EAE3B1B,sBAAsBQ,KAAKZ,S,qDAGpBvC,GACP,IAAMsE,EAAU,IAAIC,IAAQvE,GAC5BA,EAAID,OAAS,WACXuE,EAAQE,aAAc,GAExBrB,KAAKsB,kBAAkBH,K,wCAGCA,GACK,IAAD,EAAN,MAAlBnB,KAAKxB,YACPwB,KAAK3B,MAAMkD,OAAOvB,KAAKxB,WACvB,UAAAwB,KAAKvB,yBAAL,SAAwB+C,WAE1BxB,KAAKvB,kBAAoB,IAAIgD,IAAqB,CAChDC,KAAMC,IACNC,IAAKT,EACLU,gBAAiBV,EACjBzB,kBAAmB,EAGnBoC,UAAW,GACXC,UAAW,IAGb/B,KAAKxB,UAAY,IAAIwD,IAEnBhC,KAAKrB,KACLqB,KAAKvB,mBAEPuB,KAAK3B,MAAMqC,IAAIV,KAAKxB,WACpBwB,KAAK5B,SAAS2B,OAAOC,KAAK3B,MAAO2B,KAAK1B,QACtC0B,KAAKtB,YAAciB,YAAYC,Q,yCAGb,IAAD,QACjB,IAAIqC,KAAgBC,KAClB,2BACA,SAACf,GACC,EAAKG,kBAAkBH,MAEzB,SAAChF,GAAD,OAAWM,QAAQC,IAAIP,MACvB,SAACA,GAAD,OAAWM,QAAQ0F,MAAMhG,Q,yDAoBciG,GACzC,IAAItE,EAAShB,SAASC,cAAc,UACpCe,EAAOuE,MAAQD,EAAMC,MAAQ,GAC7BvE,EAAOwE,OAASF,EAAME,OAAS,GAE/B,IAAMC,EAAUzE,EAAO0E,WAAW,MAClC,GAAID,EAAS,CACXA,EAAQE,UAAUL,EAAO,EAAG,EAAGtE,EAAOuE,MAAOvE,EAAOwE,QADzC,MAEHD,EAAkBvE,EAAlBuE,MAAOC,EAAWxE,EAAXwE,OACTI,EAAYH,EAAQI,aAAa,EAAG,EAAGN,EAAOC,GAK9C3D,EAAO,IAAIC,IACfyD,EAAQ,EACRC,EAAS,EACTD,EAAQ,EACRC,EAAS,GAZA,cAcU3D,EAAKiE,UAdf,IAcX,2BAAoC,CAAC,IAA1BC,EAAyB,QAiB5BC,EAAmC,GAf/BjD,IAAUkD,UAClBF,EAAOtD,EAAI,IACV8C,EAAQ,EACTA,EAAQ,EACR,EACAA,GAU0BA,EAPlBxC,IAAUkD,UAClBF,EAAOG,EAAI,GACXV,EAAS,GACRA,EAAS,EACV,EACAA,IAMIW,EAAa,OAHTP,EAAUQ,KAAKJ,GAAkB,KAGX,OAF1BJ,EAAUQ,KAAKJ,EAAiB,GAAK,KAEE,OADvCJ,EAAUQ,KAAKJ,EAAiB,GAAK,KAE3CD,EAAOM,EAAiB,GAAbF,GApCF,8BAuCX,IAAMG,EAAQ,IAAMC,KAAKC,IAAIjB,EAAOC,GAGpC,OAFA3D,EAAKyE,MAAMA,EAAOA,EAAO,GACzBzE,EAAK4E,2BACE5E,O,KAYE6E,MAxOf,WAAgB,IAAD,EACWC,qBADX,mBACN5G,EADM,KACDqB,EADC,KAEb,OACE,sBAAKV,UAAU,MAAf,UACE,cAAC,EAAD,CAAoBX,IAAKA,IACzB,cAAC,EAAD,CAAef,WAAYoC,QCXlBwF,EAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCHdQ,IAASpE,OACP,cAAC,IAAMqE,WAAP,UACE,cAAC,EAAD,MAEFtH,SAASuH,eAAe,SAM1BX,M","file":"static/js/main.1b6850f9.chunk.js","sourcesContent":["import React, { useCallback, useEffect, useRef, useState } from \"react\";\nimport { DropEvent, FileRejection, useDropzone } from \"react-dropzone\";\nimport {\n  AmbientLight,\n  Color,\n  DirectionalLight,\n  DoubleSide,\n  MathUtils,\n  Mesh,\n  MeshStandardMaterial,\n  PerspectiveCamera,\n  PlaneGeometry,\n  Scene,\n  Texture,\n  TextureLoader,\n  WebGLRenderer\n} from \"three\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\nimport \"./App.css\";\n\nfunction App() {\n  const [img, setImage] = useState<HTMLImageElement>();\n  return (\n    <div className=\"App\">\n      <AdversaryRendering img={img} />\n      <ImageDropzone onGotImage={setImage} />\n    </div>\n  );\n}\n\nconst ImageDropzone: React.FC<{\n  onGotImage: (img: HTMLImageElement) => void;\n}> = ({ onGotImage }) => {\n  const onDrop = useCallback(\n    (files: File[], rejected: FileRejection[], event: DropEvent) => {\n      files.forEach((file) => {\n        const reader = new FileReader();\n\n        reader.onabort = () => console.log(\"file reading was aborted\");\n        reader.onerror = () => console.log(\"file reading has failed\");\n        reader.onload = () => {\n          const img = document.createElement(\"img\");\n          img.src = reader.result as string;\n          onGotImage(img);\n        };\n        reader.readAsDataURL(file);\n      });\n    },\n    [onGotImage]\n  );\n  const { getRootProps, getInputProps, isDragActive } = useDropzone({\n    onDrop,\n    maxFiles: 1,\n  });\n\n  return (\n    <div className=\"dropzone\" {...getRootProps()}>\n      <input {...getInputProps()} />\n      {isDragActive ? (\n        <p>Drop the files here ...</p>\n      ) : (\n        <p>Drag 'n' drop some files here, or click to select files</p>\n      )}\n    </div>\n  );\n};\n\nconst AdversaryRendering = ({ img }: { img: HTMLImageElement | undefined }) => {\n  const driver = useRef<AdversaryDriver>();\n  const handleRef = React.useCallback((canvas: HTMLCanvasElement | null) => {\n    if (canvas != null) {\n      driver.current = new AdversaryDriver(canvas);\n    }\n  }, []);\n  useEffect(() => {\n    if (driver.current != null && img != null) {\n      driver.current.setImage(img);\n    }\n  }, [img]);\n  return <canvas ref={handleRef}></canvas>;\n};\n\nclass AdversaryDriver {\n  public renderer: WebGLRenderer;\n  public scene: Scene;\n  public camera: PerspectiveCamera;\n  controls: OrbitControls;\n  adversary?: Mesh;\n  adversaryMaterial?: MeshStandardMaterial;\n  timeStarted = 0;\n  geom = new PlaneGeometry(200, 200, 512, 512);\n  constructor(public canvas: HTMLCanvasElement) {\n    this.renderer = new WebGLRenderer({ canvas });\n    this.renderer.setPixelRatio(window.devicePixelRatio);\n\n    this.scene = new Scene();\n\n    this.camera = new PerspectiveCamera(\n      75,\n      window.innerWidth / window.innerHeight,\n      1,\n      2000\n    );\n    this.camera.position.set(150, 0, 150);\n    this.camera.lookAt(0, 0, 0);\n\n    // also sets renderer initial size\n    this.handleWindowResize();\n    window.addEventListener(\"resize\", this.handleWindowResize);\n\n    this.scene.add(new AmbientLight(0x404040));\n    const directionalLight = new DirectionalLight(0xb2b3a1, 2);\n    directionalLight.position.set(0, 0, 10);\n    this.scene.add(directionalLight);\n    this.scene.background = new Color(1, 1, 1);\n\n    // const mesh = new Mesh(\n    //   new TorusKnotBufferGeometry(100, 30),\n    //   new MeshStandardMaterial()\n    // );\n    // this.scene.add(mesh);\n    // this.scene.add(new AxesHelper(100));\n\n    this.loadDefaultImage();\n\n    this.controls = new OrbitControls(this.camera, this.canvas);\n    this.controls.autoRotate = true;\n\n    requestAnimationFrame(this.animate);\n  }\n\n  setImage(img: HTMLImageElement) {\n    const texture = new Texture(img);\n    img.onload = function () {\n      texture.needsUpdate = true;\n    };\n    this.recreateAdversary(texture);\n  }\n\n  private recreateAdversary(texture: Texture) {\n    if (this.adversary != null) {\n      this.scene.remove(this.adversary);\n      this.adversaryMaterial?.dispose();\n    }\n    this.adversaryMaterial = new MeshStandardMaterial({\n      side: DoubleSide,\n      map: texture,\n      displacementMap: texture,\n      displacementScale: 0,\n      // displacementScale: 50,\n      // bumpMap: texture,\n      roughness: 0.5,\n      metalness: 0.0,\n    });\n    // const geom = this.generateDisplacementMappedGeometry(texture.image as HTMLImageElement);\n    this.adversary = new Mesh(\n      // geom,\n      this.geom,\n      this.adversaryMaterial\n    );\n    this.scene.add(this.adversary);\n    this.renderer.render(this.scene, this.camera);\n    this.timeStarted = performance.now();\n  }\n\n  loadDefaultImage() {\n    new TextureLoader().load(\n      \"adversaries/Buffalo.jpg\",\n      (texture) => {\n        this.recreateAdversary(texture);\n      },\n      (event) => console.log(event),\n      (event) => console.error(event)\n    );\n  }\n\n  handleWindowResize = () => {\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.camera.aspect = window.innerWidth / window.innerHeight;\n    this.camera.updateProjectionMatrix();\n  };\n\n  animate = () => {\n    requestAnimationFrame(this.animate);\n    this.controls.update();\n    if (this.adversaryMaterial != null) {\n      this.adversaryMaterial.displacementScale =\n        smoothstep(0, 5000, performance.now() - this.timeStarted) * 50;\n    }\n    this.renderer.render(this.scene, this.camera);\n  };\n\n  private generateDisplacementMappedGeometry(image: HTMLImageElement) {\n    var canvas = document.createElement(\"canvas\");\n    canvas.width = image.width / 10;\n    canvas.height = image.height / 10;\n\n    const context = canvas.getContext(\"2d\");\n    if (context) {\n      context.drawImage(image, 0, 0, canvas.width, canvas.height);\n      const { width, height } = canvas;\n      const imageData = context.getImageData(0, 0, width, height);\n      // document.body.appendChild(canvas);\n\n      // PlaneGeometry adds 1 vertex row and column, but we don't have\n      // imageData there, so we must shrink PlaneGeometry to accomodate\n      const geom = new PlaneGeometry(\n        width - 1,\n        height - 1,\n        width - 1,\n        height - 1\n      );\n      for (const vertex of geom.vertices) {\n        // -0.5 to line it up perfectly with the grid\n        const x = MathUtils.mapLinear(\n          vertex.x - 0.5,\n          -width / 2,\n          width / 2,\n          0,\n          width\n        );\n        /// invert the y!\n        const y = MathUtils.mapLinear(\n          vertex.y - 0.5,\n          height / 2,\n          -height / 2,\n          0,\n          height\n        );\n        const imageDataIndex = (x + width * y) * 4;\n        const r = imageData.data[imageDataIndex] / 255,\n          g = imageData.data[imageDataIndex + 1] / 255,\n          b = imageData.data[imageDataIndex + 2] / 255;\n        const brightness = 0.2126 * r + 0.7152 * g + 0.0722 * b;\n        vertex.z = brightness * 20;\n      }\n\n      const scale = 200 / Math.max(width, height);\n      geom.scale(scale, scale, 1);\n      geom.computeFlatVertexNormals();\n      return geom;\n    }\n  }\n}\n\nfunction smoothstep(edge0: number, edge1: number, x: number) {\n  // Scale, bias and saturate x to 0..1 range\n  x = MathUtils.clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n  // Evaluate polynomial\n  return x * x * (3 - 2 * x);\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);  \n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n}\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}